#!/usr/bin/env python2
# -*- coding: utf-8 -*-
#
#  This file is part of ypkg2
#
#  Copyright 2015-2020 Solus Project
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#

from ypkg2 import console_ui
from ypkg2.ypkgspec import YpkgSpec
from pisi.db.filesdb import FilesDB
from pisi.db.installdb import InstallDB
from pisi.db.packagedb import PackageDB
from ypkg2 import pkgconfig_dep, pkgconfig32_dep
from ypkg2.main import show_version

import sys
import os
import subprocess
import argparse
import Queue
import json
from collections import OrderedDict

def main():
    spec = YpkgSpec()

    parser = argparse.ArgumentParser(description="Ypkg Build Dep Installer")
    parser.add_argument("-n", "--no-colors", help="Disable color output",
                        action="store_true")
    parser.add_argument("-v", "--version", action="store_true",
                        help="Show version information and exit")
    parser.add_argument("-f", "--force", help="Force install dependencies, "
                        "i.e. no prompt", action="store_true")
    parser.add_argument("-D", "--output-dir", type=str,
                        help="Ignored in ypkg-install-deps")
    parser.add_argument("--dry-run", help="Don't install anyting",
                        action="store_true")
    parser.add_argument("--json", help="Dump json info of all packages that should be "
                        "installed when building package", action="store_true")
    # Main file
    parser.add_argument("filename", help="Path to the ypkg YAML file")

    args = parser.parse_args()
    # Kill colors
    if args.no_colors:
        console_ui.allow_colors = False
    # Show version
    if args.version:
        show_version()
    # Disallow logging if outputting json
    if args.json:
        console_ui.quiet = True

    # Grab filename
    if not args.filename:
        console_ui.emit_error("Error", "Please provide a filename")
        print("")
        parser.print_help()
        sys.exit(1)

    if not spec.load_from_path(args.filename):
        sys.exit(1)

    pc32deps = set()
    pcdeps = set()
    ndeps = set()
    full_deps = set()

    idb = InstallDB()
    pdb = PackageDB()
    fdb = FilesDB()

    console_ui.emit_info("BuildDep", "Checking build-deps for {}-{}-{}".
                         format(spec.pkg_name, spec.pkg_version,
                                spec.pkg_release))

    if spec.pkg_builddeps:
        for dep in spec.pkg_builddeps:
            em32 = pkgconfig32_dep.match(dep)
            if em32:
                pc32deps.add(em32.group(1))
                continue
            em = pkgconfig_dep.match(dep)
            if em:
                pcdeps.add(em.group(1))
                continue
            full_deps.add(dep)
            if not idb.has_package(dep):
                ndeps.add(dep)

    if spec.pkg_checkdeps:
        for dep in spec.pkg_checkdeps:
            em32 = pkgconfig32_dep.match(dep)
            if em32:
                pc32deps.add(em32.group(1))
                continue
            em = pkgconfig_dep.match(dep)
            if em:
                pcdeps.add(em.group(1))
                continue
            full_deps.add(dep)
            if not idb.has_package(dep):
                ndeps.add(dep)

    # Get the global known pkgconfig providers
    pkgConfigs, pkgConfigs32 = pdb.get_pkgconfig_providers()

    for i in pc32deps:
        local = False
        pkg = None

        # Try global pkgconfig names first.
        if i in pkgConfigs32:
            pkg = pdb.get_package(pkgConfigs32[i])
        elif i in pkgConfigs:
            pkg = pdb.get_package(pkgConfigs[i])

        # Try the filesdb
        if not pkg:
            local = True
            nom = fdb.get_pkgconfig32_provider(i)
            if nom:
                pkg = idb.get_package_by_pkgconfig32(nom[0])
        if not pkg:
            nom = fdb.get_pkgconfig_provider(i)
            if nom:
                pkg = idb.get_package_by_pkgconfig(nom[0])

        if local:
            console_ui.emit_warning("pkgconfig32:{}".format(i),
                                    "This dependency is not in any repo")
        if not pkg:
            console_ui.emit_error("BuildDep", "pkgconfig32({}) build dep "
                                  "doesn't exist in the repository.".format(i))
            sys.exit(1)

        if not idb.has_package(pkg.name):
            ndeps.add(pkg.name)

    for i in pcdeps:
        local = False
        pkg = None
        if i in pkgConfigs:
            pkg = pdb.get_package(pkgConfigs[i])
        if not pkg:
            nom = fdb.get_pkgconfig_provider(i)
            if nom:
                pkg = idb.get_package_by_pkgconfig(nom[0])
            local = True
        if local:
            console_ui.emit_warning("pkgconfig:{}".format(i),
                                    "This dependency is not in any repo")
        if not pkg:
            console_ui.emit_error("BuildDep", "pkgconfig({}) build dep"
                                  " does not exist in the repository.".
                                  format(i))
            sys.exit(1)

        full_deps.add(pkg.name)
        if not idb.has_package(pkg.name):
            ndeps.add(pkg.name)

    if len(ndeps) < 1 and not args.json:
        console_ui.emit_success("BuildDep", "All build deps satisfied")
        sys.exit(0)

    if os.geteuid() != 0:
        cmd = "sudo eopkg install {}".format(" ".join(ndeps))
    else:
        cmd = "eopkg install {}".format(" ".join(ndeps))

    if args.force:
        cmd += " --yes-all"

    if args.no_colors:
        cmd += " -N"

    invalid = [x for x in ndeps if not pdb.has_package(x)]
    if len(invalid) > 0:
        console_ui.emit_error("BuildDep", "Unknown build deps: {}".
                              format(" ".join(invalid)))
        sys.exit(1)

    if not args.dry_run:
        console_ui.emit_info("BuildDep", "Requesting installation of: {}".
                             format(", ".join(ndeps)))
        try:
            subprocess.check_call(cmd, shell=True)
        except Exception as e:
            console_ui.emit_error("BuildDep", "Failed to install build deps")
            sys.exit(1)
    elif args.json:
        json_pkgs = []
        queue = Queue.Queue()
        for dep in full_deps:
            queue.put(dep)

        while not queue.empty():
            dep = queue.get()
            dpkg = pdb.get_package(dep)
            if not dpkg:
                console_ui.emit_error("JSON", "Unknown build dep: {}".format(dep))
                sys.exit(1)

            json_pkgs.append({key: getattr(dpkg, key) for key in ["name", "version", "release", "packageHash"]})
            for ddep in dpkg.runtimeDependencies():
                if not ddep.satisfied_by_repo():
                    console_ui.emit_error("JSON",
                        "%s depends on %s but latter is not satisfied" % (dep, ddep.name()))
                    sys.exit(1)

                if ddep.name() in full_deps:
                    continue
                queue.put(ddep.name())
                full_deps.add(ddep.name())

        for ipkg in idb.list_installed():
            if ipkg in full_deps:
                continue

            pkg = pdb.get_package(ipkg)
            if not pkg:
                console_ui.emit_error("JSON", "why is %s installed but doesn't exist in package db?" % ipkg)
                sys.exit(1)
            json_pkgs.append(
                OrderedDict([(key, getattr(pkg, key)) for key in ["name",
                                                                  "version",
                                                                  "release",
                                                                  "packageHash"]]))

        json_pkgs = sorted(json_pkgs, key=lambda j: j["name"])
        print(json.dumps(json_pkgs))


    sys.exit(0)

if __name__ == "__main__":
    main()
